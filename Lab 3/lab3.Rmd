---
title: "Lab 3 — Practical Applications: Experiments, Balance, Noncompliance, Instruments, Attrition (with DAGs)"
author: "Causal Inference Lab"
date: "`r format(Sys.Date(), '%Y-%m-%d')`"
output:
  html_document:
    toc: true
    toc_depth: 3
    number_sections: true
    theme: readable
    df_print: paged
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  message = FALSE,
  warning = FALSE,
  fig.width = 7,
  fig.height = 4.5
)
options(width = 120)
set.seed(123)
```

# 1) Purpose of this lab

This lab is a practical companion to the lecture. We focus on:

- **Experiments** (randomization and interpretation as causal)
- **Balance** (diagnostics for randomization)
- **Noncompliance** (assignment vs treatment received)
- **Instrumental variables** (IV / Wald / 2SLS as LATE under assumptions)
- **Attrition** (missing outcomes and what it breaks)
- *(Optional)* **covariate adjustment for precision**

We will:
1) sketch **DAGs** for two motivating examples (Identity; Masking),
2) practice with **generated data**,
3) end with a **template** to keep only replication-package parts relevant to these topics for Aggarwal et al. (2023).

---

# 2) Packages

```{r packages}
pkgs <- c(
  "tidyverse", "dagitty", "ggdag",
  "estimatr", "AER", "broom", "modelsummary",
  "patchwork", "here"
)

to_install <- pkgs[!sapply(pkgs, requireNamespace, quietly = TRUE)]
if(length(to_install) > 0) install.packages(to_install)

library(tidyverse)
library(dagitty)
library(ggdag)
library(estimatr)
library(AER)
library(broom)
library(modelsummary)
library(patchwork)
library(here)
```

---

# 3) Motivating examples (DAGs only)

## 3.1 Social identity and social preferences (Chen & Li 2009): DAG sketch

**Simplified causal story**

- `A`: random assignment to identity prime
- `P`: psychological salience / identity activation (mechanism)
- `Y`: pro-social behavior (e.g., allocation/choice)
- `D`: baseline traits (pre-treatment), e.g., altruism, demographics

Key idea: because `A` is randomized, `A ⟂ D`, so comparing by `A` is causal for **assignment**.

```{r dag-identity}
dag_identity <- dagitty("
dag {

  D -> Y
  A -> P
  P -> Y
}
")

ggdag(dag_identity) + theme_dag()
```

**Lab note:** Regressing `Y ~ A` estimates the ITT. Regressing `Y ~ P` may be confounded because `D` might affect `P`.

---

## 3.2 Community masking during COVID (Abaluck et al. 2022): DAG sketch

**Simplified causal story** (cluster RCT)

- `Z`: village-level assignment to mask campaign
- `M`: mask wearing (uptake/compliance)
- `Y`: COVID outcomes (symptoms/seroprevalence)
- `D`: baseline risk factors / mixing patterns (pre-treatment)

```{r dag-masking}
dag_masking <- dagitty("
dag {


  D -> Y
  Z -> M
  M -> Y
}
")

ggdag(dag_masking) + theme_dag()
```

**Lab note:** In cluster RCTs, use cluster-robust SEs and consider spillovers/interference (not covered here).

---

# 4) Generated data playground (one dataset for all concepts)

We create:
- baseline covariates `X`,
- randomized assignment `Z`,
- treatment received `D` with **noncompliance**,
- outcome `Y`,
- missing outcome indicator `R` to represent **attrition**.

```{r simulate-data}
n <- 3000

df <- tibble(
  id = 1:n,
  # Pre-treatment covariates (X)
  age = round(rnorm(n, mean = 40, sd = 12)),
  female = rbinom(n, 1, 0.55),
  baseline_interest = rnorm(n, 0, 1),
  # Random assignment (Z)
  Z = rbinom(n, 1, 0.5)
)

# Noncompliance: D depends on Z and baseline_interest (so D is NOT randomized)
logit_pD <- -1.2 + 1.5 * df$Z + 0.7 * df$baseline_interest
pD <- plogis(logit_pD)

df <- df %>% mutate(D = rbinom(n, 1, pD))

# Outcome depends on D and pre-treatment covariates
df <- df %>% mutate(
  Y = 0.2 * D +
    0.05 * (age - 40) / 12 +
    0.1 * female +
    0.25 * baseline_interest +
    rnorm(n, 0, 1)
)

# Attrition: missingness depends on covariates (NOT MCAR)
logit_miss <- -2.2 + 0.6 * df$baseline_interest + 0.3 * (df$age > 55)
p_miss <- plogis(logit_miss)

df <- df %>%
  mutate(R = rbinom(n, 1, p_miss)) %>%         # R=1 means missing outcome
  mutate(Y_obs = ifelse(R == 1, NA, Y))

glimpse(df)
```

---

# 5) Experiment: ITT (effect of assignment)

Because `Z` is randomized, comparing `Y` by `Z` identifies an **intent-to-treat** effect (ITT).

```{r itt}
itt <- lm_robust(Y_obs ~ Z, data = df, se_type = "stata")
tidy(itt)
```

**Interpretation:** coefficient on `Z` is \(E[Y|Z=1] - E[Y|Z=0]\) using observed outcomes.

---

# 6) Balance: did randomization create comparable groups?

Balance checks compare pre-treatment covariates across `Z`.

## 6.1 Simple balance table

```{r balance-table}
balance_tbl <- df %>%
  group_by(Z) %>%
  summarize(
    n = n(),
    mean_age = mean(age),
    mean_female = mean(female),
    mean_interest = mean(baseline_interest),
    .groups = "drop"
  )
balance_tbl
```

## 6.2 Regression-based balance checks

```{r balance-reg}
m_age <- lm_robust(age ~ Z, data = df)
m_female <- lm_robust(female ~ Z, data = df)
m_interest <- lm_robust(baseline_interest ~ Z, data = df)

modelsummary(
  list("Age" = m_age, "Female" = m_female, "Baseline interest" = m_interest),
  statistic = "({std.error})",
  gof_omit = "IC|Log|Adj|Within"
)
```

---

# 7) Noncompliance: assignment vs treatment received

Here, `D` is not randomized (it depends on covariates), even though `Z` is randomized.

## 7.1 Naive comparison by D (potentially biased)

```{r naive-by-D}
naive_D <- lm_robust(Y_obs ~ D, data = df, se_type = "stata")
tidy(naive_D)
```

This can be biased because `baseline_interest` affects both `D` and `Y`.

## 7.2 First stage: does Z move D?

```{r first-stage}
fs <- lm_robust(D ~ Z, data = df, se_type = "stata")
tidy(fs)
```

The coefficient on `Z` is \(E[D|Z=1] - E[D|Z=0]\): “encouragement strength.”

---

# 8) Instrument: IV / Wald / 2SLS

If:
1) `Z` affects `Y` only through `D` (exclusion restriction),
2) no defiers (monotonicity),
3) `Z` is randomized (independent of potential outcomes),

then IV identifies a **LATE** for compliers.

## 8.1 Wald estimator (ratio)

```{r wald}
ITT_Y <- coef(itt)["Z"]
ITT_D <- coef(fs)["Z"]
wald <- ITT_Y / ITT_D
wald
```

## 8.2 Two-stage least squares (2SLS)

```{r iv-2sls}
iv_fit <- ivreg(Y_obs ~ D | Z, data = df)
summary(iv_fit)
```

---

# 9) Attrition: missing outcomes

We created missingness `R` that depends on covariates. Attrition can threaten causal interpretation if missingness differs by assignment or is related to outcomes.

## 9.1 Is attrition related to assignment?

```{r attrition-by-Z}
attr_tbl <- df %>%
  group_by(Z) %>%
  summarize(
    missing_rate = mean(is.na(Y_obs)),
    .groups = "drop"
  )
attr_tbl

attr_Z <- lm_robust(I(is.na(Y_obs)) ~ Z, data = df, se_type = "stata")
tidy(attr_Z)
```

## 9.2 Is attrition related to baseline covariates?

```{r attrition-covars}
attr_cov <- lm_robust(I(is.na(Y_obs)) ~ age + female + baseline_interest + Z, data = df, se_type = "stata")
tidy(attr_cov)
```

**Lab discussion:** If attrition is selective, you at least (i) report it, (ii) diagnose it, and (iii) consider robustness strategies (bounds, weighting, sensitivity).

---

# 10) Optional: Covariate adjustment for precision

Even with randomization, controlling for strong predictors of `Y` can improve precision.

```{r precision}
itt_adj <- lm_robust(Y_obs ~ Z + age + female + baseline_interest, data = df, se_type = "stata")

modelsummary(
  list("ITT (unadjusted)" = itt, "ITT (adjusted)" = itt_adj),
  statistic = "({std.error})",
  gof_omit = "IC|Log|Adj|Within"
)
```

---

# 11) Applied template: Aggarwal et al. (2023) digital advertising & turnout

Goal: keep only the replication-package components relevant to *today’s topics*:
- randomization / ITT
- balance
- noncompliance + IV (if applicable)
- attrition / sample construction
- (optional) precision adjustment

**Paper DOI:** https://doi.org/10.1038/s41562-022-01487-4  
**Replication package:** https://isps.yale.edu/research/data/d199

## 11.1 Set the replication root folder

Unzip the replication package, then set a local path:

```{r aggarwal-path, eval=FALSE}
# CHANGE THIS to your local folder path
rep_root <- "PATH/TO/UNZIPPED/REPLICATION_PACKAGE"

list.files(rep_root)
```

## 11.2 Create a "Lab 3 subset" folder

This copies only files likely relevant to our topics, based on keywords.
You will probably tweak the keywords after inspecting the folder structure.

```{r aggarwal-subset, eval=FALSE}
subset_dir <- file.path(rep_root, "lab3_subset")
dir.create(subset_dir, showWarnings = FALSE)

# Common folder names (adjust if your package differs)
code_dir <- file.path(rep_root, "code")
data_dir <- file.path(rep_root, "data")

all_code <- if(dir.exists(code_dir)) list.files(code_dir, recursive = TRUE, full.names = TRUE) else character(0)
all_data <- if(dir.exists(data_dir)) list.files(data_dir, recursive = TRUE, full.names = TRUE) else character(0)

keep_code <- all_code[
  str_detect(tolower(all_code),
             "clean|build|analysis|main|itt|balance|random|attrit|missing|iv|2sls|firststage|compliance|sample")
]

keep_data <- all_data[
  str_detect(tolower(all_data),
             "analysis|final|clean|derived|turnout|assignment|treat|exposure|merged|match|link|sample")
]

dir.create(file.path(subset_dir, "code"), showWarnings = FALSE)
dir.create(file.path(subset_dir, "data"), showWarnings = FALSE)

file.copy(keep_code, file.path(subset_dir, "code"), overwrite = TRUE)
file.copy(keep_data, file.path(subset_dir, "data"), overwrite = TRUE)

writeLines(
  c("CODE FILES:", keep_code, "", "DATA FILES:", keep_data),
  file.path(subset_dir, "MANIFEST_lab3_subset.txt")
)

list.files(subset_dir, recursive = TRUE)
```

## 11.3 Load the analysis dataset (you adapt file name)

```{r aggarwal-load, eval=FALSE}
library(readr)

# Replace with the actual dataset name you find:
dat_path <- file.path(rep_root, "lab3_subset", "data", "analysis_data.csv")
ad <- read_csv(dat_path)
glimpse(ad)
```

## 11.4 Map variables to lab notation

Create a standardized analysis frame:
- `Z`: assignment (randomized encouragement)
- `D`: treatment received / exposure (if different from Z)
- `Y`: turnout outcome
- `X`: pre-treatment covariates
- `cluster_id`: if assignment is clustered
- `R`: missingness indicator (attrition)

```{r aggarwal-map, eval=FALSE}
ad2 <- ad %>%
  transmute(
    Z = assigned_treatment,     # <-- change
    D = actual_exposure,        # <-- change (or set D = Z if perfect compliance)
    Y = turnout,                # <-- change
    cluster_id = geo_cluster,   # <-- optional / change
    # Covariates (edit)
    age = age,
    female = female,
    past_turnout = past_turnout
  ) %>%
  mutate(R = is.na(Y))

glimpse(ad2)
```

## 11.5 ITT

```{r aggarwal-itt, eval=FALSE}
itt_ag <- lm_robust(Y ~ Z, data = ad2, se_type = "stata")
tidy(itt_ag)
```

If clustered assignment, do:

```{r aggarwal-itt-cluster, eval=FALSE}
itt_ag_cl <- lm_robust(Y ~ Z, data = ad2, se_type = "CR2", clusters = cluster_id)
tidy(itt_ag_cl)
```

## 11.6 Balance

```{r aggarwal-balance, eval=FALSE}
balance_covars <- c("age", "female", "past_turnout")

bal <- lapply(balance_covars, function(v){
  f <- as.formula(paste(v, "~ Z"))
  lm_robust(f, data = ad2) %>% tidy() %>% mutate(var = v)
}) %>% bind_rows()

bal %>% filter(term == "Z") %>% select(var, estimate, std.error, p.value)
```

## 11.7 Noncompliance & IV (only if D differs from Z)

```{r aggarwal-iv, eval=FALSE}
# First stage
fs_ag <- lm_robust(D ~ Z, data = ad2, se_type = "stata")
tidy(fs_ag)

# Wald ratio
ITT_Y_ag <- coef(itt_ag)["Z"]
ITT_D_ag <- coef(fs_ag)["Z"]
wald_ag <- ITT_Y_ag / ITT_D_ag
wald_ag

# 2SLS
iv_ag <- ivreg(Y ~ D | Z, data = ad2)
summary(iv_ag)
```

## 11.8 Attrition diagnostics

```{r aggarwal-attrition, eval=FALSE}
# Missingness by assignment
lm_robust(R ~ Z, data = ad2, se_type = "stata") %>% tidy()

# Missingness by covariates + assignment
lm_robust(R ~ Z + age + female + past_turnout, data = ad2, se_type = "stata") %>% tidy()
```

## 11.9 Optional: precision adjustment

```{r aggarwal-precision, eval=FALSE}
adj_ag <- lm_robust(Y ~ Z + age + female + past_turnout, data = ad2, se_type = "stata")
modelsummary(
  list("ITT unadjusted" = itt_ag, "ITT adjusted" = adj_ag),
  statistic = "({std.error})",
  gof_omit = "IC|Log|Adj|Within"
)
```

---

# 12) DAG wrap-up for the digital ads setting (assignment + noncompliance)

A standard “encouragement design” DAG:

- `Z` (random assignment) affects `D` (exposure/treatment received),
- `D` affects `Y` (turnout),
- baseline covariates `X` affect both `D` and `Y`.

```{r dag-ads}
dag_ads <- dagitty("
dag {
  X [pos='0,0']
  Z [pos='1,1']
  D [pos='2,1']
  Y [pos='3,0']

  X -> D
  X -> Y
  Z -> D
  D -> Y
}
")

ggdag(dag_ads, text = FALSE) + theme_dag()
```

**Key links to concepts in this lab:**
- `Z -> Y` identifies ITT (experiment)
- balance checks test `Z ⟂ X` in sample (diagnostic)
- `Z -> D` is the first stage (noncompliance)
- IV uses `Z` to identify effect of `D` on `Y` under assumptions
- attrition threatens interpretation if missingness depends on `Z` or on outcome-related variables

---
